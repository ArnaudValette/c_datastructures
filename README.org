* C Datastructures
C datastructures in single header files. They come in different flavors (typed, untyped).
* Table of Contents
- [[#DEQUE][DEQUE]]
- [[#HASHMAP][HASHMAP]]
---------------
** DEQUE
This header provides a small, header-only implementation of a double-ended queue (deque) backed by a dynamically resized circular array.

It supports constant-time amortized insertion and removal at both ends and can be used either in a strongly typed way (macro-based) or as a generic void * container.

The default mode is the typed implementation.

*** Features
- Header-only, no compilation unit required
- O(1) amortized push and pop on both ends
- Circular buffer implementation
- Automatic resizing by capacity doubling
- Optional compile-time type safety
- No ownership over stored objects (pointers only)
- Minimal and predictable memory model

*** API
- =deque_create=
- =deque_destroy=
- =deque_is_empty=
- =deque_len=
- =deque_get=
- =deque_append=
- =deque_push=
- =deque_pop=
- =deque_pop_last=
*** Configuration

By default, the typed macro-based deque is used.
To enable the generic void * version, define:

#+begin_src c
#define DATASTRUCT_USE_VOID_BASED_DEQUE
#+end_src

before including deque.h.

If this macro is not defined, the typed version is selected.

You may define =DEQUE_INITIAL_SIZE= *after having included the header* (defaulted at 128) :
#+begin_src c
#define DEQUE_INITIAL_SIZE 16 
#+end_src

*** Typed version:
#+begin_src c
  #include "deque.h"
  /* i_deque */
  DEQUE_TYPEDECL(int, i)
  DEQUE_IMPL(int, i)

  int main(){
    i_deque my_first_deque = i_deque_create();
  }
#+end_src

#+begin_src c
  typedef struct {
      int value;
  } Node;

  /* Generating node_deque and its related functions : */
  DEQUE_TYPEDECL(Node, node)
  DEQUE_IMPL(Node, node)

  int main(void) {
    node_deque *dq = node_deque_create();

    Node *a = malloc(sizeof(Node));
    Node *b = malloc(sizeof(Node));
    a->value = 1;
    b->value = 2;

    node_deque_append(dq, a); // back
    node_deque_push(dq, b); // front

    Node *x = node_deque_pop(dq); // b
    Node *y = node_deque_pop_last(dq); // a

    node_deque_destroy(dq);
  }
#+end_src

*** (void *) version :

#+begin_src c
deque *dq = deque_create();

int *a = malloc(sizeof(int));
int *b = malloc(sizeof(int));
*a = 10;
*b = 20;

deque_append(dq, a);
deque_push(dq, b);

int *x = deque_pop(dq);
int *y = deque_pop_last(dq);

deque_destroy(dq);
#+end_src
** HASHMAP
This header provides a small, header-only implementation of a chained hashmap with automatic resizing.

It uses separate chaining with linked lists and a 64-bit hash function inspired by xxHash.
The implementation is available in two forms:

- a macro-based typed version (*note* : /work-in-progress/)
- and a simpler, untyped =(void *)->(void *)= based version.

*** Features

- Header-only, no compilation unit required
- Separate chaining collision handling
- O(1) amortized insertion, lookup, and deletion
- Automatic resizing by capacity doubling
- 64-bit hash function (xxHash-like)
- No ownership over stored keys or values
- Predictable memory model

*** Data model
Each entry is:

#+begin_src c
typedef struct entry {
  void *key;
  size_t key_len;
  uint64_t hash;
  void *value;
  struct entry *next;
} entry;

#+end_src

The hashmap itself is:

#+begin_src c
typedef struct {
  entry **buckets;
  uint64_t seed;
  size_t width;
  size_t size;
} hashmap;
#+end_src


*** Configuration

You may redefine:

#+begin_src c
#define HASHMAP_INITIAL_SIZE 128
#+end_src


The integer-only load factor check currently corresponds to 0.75.

*** API

- =hashmap_new(uint64_t seed)=
- =hashmap_destroy(hashmap *hm)=
- =hashmap_put(hashmap *hm, void *key, size_t key_len, void *value)=
- =hashmap_get(hashmap *hm, void *key, size_t key_len)=
- =hashmap_delete(hashmap *hm, void *key, size_t key_len)=

All functions are static and header-only.

*** Ownership model

The hashmap *does* own keys.
The hasmap *does not* own values.

You must ensure values remain valid while stored.
You must free values yourself if they were dynamically allocated.

*** Example

#+begin_src c
  hashmap *hm1 = hashmap_new(0xdeadbeef);

  int *a = malloc(sizeof(int));
  ,*a = 10;

  int *b = malloc(sizeof(int));
  ,*b = 20;

  hashmap_put(hm1, "foo", 3, a);
  hashmap_put(hm1, "bar", 3, b);

  int *x = hashmap_get(hm1, "foo", 3); // 10
  int *y = hashmap_get(hm1, "bar", 3); // 20

  hashmap_delete(hm1, "foo", 3);

  hashmap_destroy(hm1);

  /* free values manually */
  free(a);
  free(b);

  typedef struct {
    int    id;
    double score;
    char   tag[8];
  } Key;

  typedef struct {
    char name[32];
    int  level;
  } Value;

  hashmap *hm2 = hashmap_new(0xdeadbeef);

  /* create some keys */
  Key k1 = {
    .id = 1,
    .score = 42.5,
    .tag = "alpha"
  };

  Key k2 = {
    .id = 2,
    .score = 13.37,
    .tag = "beta"
  };

  /* create some values */
  Value *v1 = malloc(sizeof(Value));
  strcpy(v1->name, "first object");
  v1->level = 10;

  Value *v2 = malloc(sizeof(Value));
  strcpy(v2->name, "second object");
  v2->level = 20;

  /* insert */
  hashmap_put(hm2, &k1, sizeof(Key), v1);
  hashmap_put(hm2, &k2, sizeof(Key), v2);

  /*
    At this point:
    - the hashmap has copied the raw bytes of k1 and k2
    - it does NOT store &k1 or &k2
    - it owns its internal copies
  ,*/
#+end_src

*** Notes

- Hashes are stored in entries to avoid recomputation during resize.
- Resizing performs a full rehash into a new bucket table.
- Collision handling uses simple head insertion for cache efficiency.
