* C Datastructures
C datastructures in single header files. They come in different flavors (typed, untyped).
** DEQUE
This header provides a small, header-only implementation of a double-ended queue (deque) backed by a dynamically resized circular array.

It supports constant-time amortized insertion and removal at both ends and can be used either in a strongly typed way (macro-based) or as a generic void * container.

The default mode is the typed implementation.

*** Features
- Header-only, no compilation unit required
- O(1) amortized push and pop on both ends
- Circular buffer implementation
- Automatic resizing by capacity doubling
- Optional compile-time type safety
- No ownership over stored objects (pointers only)
- Minimal and predictable memory model

*** API
- =deque_create=
- =deque_destroy=
- =deque_is_empty=
- =deque_len=
- =deque_get=
- =deque_append=
- =deque_push=
- =deque_pop=
- =deque_pop_last=
*** Configuration

By default, the typed macro-based deque is used.
To enable the generic void * version, define:

#+begin_src c
#define DATASTRUCT_USE_VOID_BASED_DEQUE
#+end_src

before including deque.h.

If this macro is not defined, the typed version is selected.

You may define =DEQUE_INITIAL_SIZE= *after having included the header* (defaulted at 128) :
#+begin_src c
#define DEQUE_INITIAL_SIZE 16 
#+end_src

*** Typed version:
#+begin_src c
  #include "deque.h"
  /* i_deque */
  DEQUE_TYPEDECL(int, i)
  DEQUE_IMPL(int, i)

  int main(){
    i_deque my_first_deque = i_deque_create();
  }
#+end_src

#+begin_src c
  typedef struct {
      int value;
  } Node;

  /* Generating node_deque and its related functions : */
  DEQUE_TYPEDECL(Node, node)
  DEQUE_IMPL(Node, node)

  int main(void) {
    node_deque *dq = node_deque_create();

    Node *a = malloc(sizeof(Node));
    Node *b = malloc(sizeof(Node));
    a->value = 1;
    b->value = 2;

    node_deque_append(dq, a); // back
    node_deque_push(dq, b); // front

    Node *x = node_deque_pop(dq); // b
    Node *y = node_deque_pop_last(dq); // a

    node_deque_destroy(dq);
  }
#+end_src

*** (void *) version :

#+begin_src c
deque *dq = deque_create();

int *a = malloc(sizeof(int));
int *b = malloc(sizeof(int));
*a = 10;
*b = 20;

deque_append(dq, a);
deque_push(dq, b);

int *x = deque_pop(dq);
int *y = deque_pop_last(dq);

deque_destroy(dq);
#+end_src
** HASHMAP
This header provides a small, header-only implementation of a chained hashmap with automatic resizing.

It uses separate chaining with linked lists and a 64-bit hash function inspired by xxHash.
The implementation is available in two forms:

- a macro-based typed version (*note* : /work-in-progress/)
- and a simpler, untyped =(char *)->(void *)= based version.

The hashmap does not own keys or values: it only stores pointers. Memory ownership stays with the caller.

*** Features

- Header-only, no compilation unit required
- Separate chaining collision handling
- O(1) amortized insertion, lookup, and deletion
- Automatic resizing by capacity doubling
- 64-bit hash function (xxHash-like)
- No ownership over stored keys or values
- Predictable memory model

*** Data model
Each entry is:

#+begin_src c
typedef struct entry {
  char *key;
  uint64_t hash;
  void *value;
  struct entry *next;
} entry;

#+end_src

The hashmap itself is:

#+begin_src c
typedef struct {
  entry **buckets;
  uint64_t seed;
  size_t width;
  size_t size;
} hashmap;
#+end_src


*** Configuration

You may redefine:

#+begin_src c
#define HASHMAP_INITIAL_SIZE 128
#+end_src


The integer-only load factor check currently corresponds to 0.75.

*** API

- =hashmap_new=
- =hashmap_destroy=
- =hashmap_put=
- =hashmap_get=
- =hashmap_delete=

All functions are static and header-only.

*** Ownership model

The hashmap does not own keys or values.

You must ensure keys remain valid while stored.
You must free keys/values yourself if they were dynamically allocated.

*** Example

#+begin_src c
hashmap *hm = hashmap_new(0xdeadbeef);

int *a = malloc(sizeof(int));
*a = 10;

int *b = malloc(sizeof(int));
*b = 20;

hashmap_put(hm, "foo", a);
hashmap_put(hm, "bar", b);

int *x = hashmap_get(hm, "foo"); // 10
int *y = hashmap_get(hm, "bar"); // 20

hashmap_delete(hm, "foo");

hashmap_destroy(hm);

/* free values manually */
free(a);
free(b);
#+end_src

*** Notes

- Hashes are stored in entries to avoid recomputation during resize.
- Resizing performs a full rehash into a new bucket table.
- Collision handling uses simple head insertion for cache efficiency.
